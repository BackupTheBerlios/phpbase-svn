<?php
 require_once(dirname(__FILE__) . '/test_case.php'); require_once(dirname(__FILE__) . '/errors.php'); require_once(dirname(__FILE__) . '/dumper.php'); class UnitTestCase extends SimpleTestCase { function UnitTestCase($label = false) { if (! $label) { $label = get_class($this); } $this->SimpleTestCase($label); } function assertNull($value, $message = "%s") { $dumper = &new SimpleDumper(); $message = sprintf( $message, "[" . $dumper->describeValue($value) . "] should be null"); return $this->assertTrue(! isset($value), $message); } function assertNotNull($value, $message = "%s") { $dumper = &new SimpleDumper(); $message = sprintf( $message, "[" . $dumper->describeValue($value) . "] should not be null"); return $this->assertTrue(isset($value), $message); } function assertIsA($object, $type, $message = "%s") { return $this->assert( new IsAExpectation($type), $object, $message); } function assertNotA($object, $type, $message = "%s") { return $this->assert( new NotAExpectation($type), $object, $message); } function assertEqual($first, $second, $message = "%s") { return $this->assert( new EqualExpectation($first), $second, $message); } function assertNotEqual($first, $second, $message = "%s") { return $this->assert( new NotEqualExpectation($first), $second, $message); } function assertWithinMargin($first, $second, $margin, $message = "%s") { return $this->assert( new WithinMarginExpectation($first, $margin), $second, $message); } function assertOutsideMargin($first, $second, $margin, $message = "%s") { return $this->assert( new OutsideMarginExpectation($first, $margin), $second, $message); } function assertIdentical($first, $second, $message = "%s") { return $this->assert( new IdenticalExpectation($first), $second, $message); } function assertNotIdentical($first, $second, $message = "%s") { return $this->assert( new NotIdenticalExpectation($first), $second, $message); } function assertReference(&$first, &$second, $message = "%s") { $dumper = &new SimpleDumper(); $message = sprintf( $message, "[" . $dumper->describeValue($first) . "] and [" . $dumper->describeValue($second) . "] should reference the same object"); return $this->assertTrue( SimpleTestCompatibility::isReference($first, $second), $message); } function assertCopy(&$first, &$second, $message = "%s") { $dumper = &new SimpleDumper(); $message = sprintf( $message, "[" . $dumper->describeValue($first) . "] and [" . $dumper->describeValue($second) . "] should not be the same object"); return $this->assertFalse( SimpleTestCompatibility::isReference($first, $second), $message); } function assertPattern($pattern, $subject, $message = "%s") { return $this->assert( new PatternExpectation($pattern), $subject, $message); } function assertWantedPattern($pattern, $subject, $message = "%s") { return $this->assertPattern($pattern, $subject, $message); } function assertNoPattern($pattern, $subject, $message = "%s") { return $this->assert( new NoPatternExpectation($pattern), $subject, $message); } function assertNoUnwantedPattern($pattern, $subject, $message = "%s") { return $this->assertNoPattern($pattern, $subject, $message); } function assertNoErrors($message = "%s") { $queue = &SimpleErrorQueue::instance(); return $this->assertTrue( $queue->isEmpty(), sprintf($message, "Should be no errors")); } function assertError($expected = false, $message = "%s") { $queue = &SimpleErrorQueue::instance(); if ($queue->isEmpty()) { $this->fail(sprintf($message, "Expected error not found")); return; } list($severity, $content, $file, $line, $globals) = $queue->extract(); $severity = SimpleErrorQueue::getSeverityAsString($severity); if (! $expected) { return $this->pass( "Captured a PHP error of [$content] severity [$severity] in [$file] line [$line] -> %s"); } $expected = $this->_coerceToExpectation($expected); return $this->assert( $expected, $content, "Expected PHP error [$content] severity [$severity] in [$file] line [$line] -> %s"); } function _coerceToExpectation($expected) { if (SimpleTestCompatibility::isA($expected, 'SimpleExpectation')) { return $expected; } return new EqualExpectation($expected); } function assertErrorPattern($pattern, $message = "%s") { return $this->assertError(new PatternExpectation($pattern), $message); } } ?>
