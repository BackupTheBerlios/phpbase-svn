<?php
 require_once(dirname(__FILE__) . '/expectation.php'); require_once(dirname(__FILE__) . '/simpletest.php'); require_once(dirname(__FILE__) . '/dumper.php'); if (version_compare(phpversion(), '5') >= 0) { require_once(dirname(__FILE__) . '/reflection_php5.php'); } else { require_once(dirname(__FILE__) . '/reflection_php4.php'); } if (! defined('MOCK_ANYTHING')) { define('MOCK_ANYTHING', '*'); } class AnythingExpectation extends SimpleExpectation { function test($compare) { return true; } function testMessage($compare) { $dumper = &$this->_getDumper(); return 'Anything always matches [' . $dumper->describeValue($compare) . ']'; } } class ParametersExpectation extends SimpleExpectation { var $_expected; function ParametersExpectation($expected = false, $message = '%s') { $this->SimpleExpectation($message); $this->_expected = $expected; } function test($parameters) { if (! is_array($this->_expected)) { return true; } if (count($this->_expected) != count($parameters)) { return false; } for ($i = 0; $i < count($this->_expected); $i++) { if (! $this->_testParameter($parameters[$i], $this->_expected[$i])) { return false; } } return true; } function _testParameter($parameter, $expected) { $comparison = $this->_coerceToExpectation($expected); return $comparison->test($parameter); } function testMessage($parameters) { if ($this->test($parameters)) { return "Expectation of " . count($this->_expected) . " arguments of [" . $this->_renderArguments($this->_expected) . "] is correct"; } else { return $this->_describeDifference($this->_expected, $parameters); } } function _describeDifference($expected, $parameters) { if (count($expected) != count($parameters)) { return "Expected " . count($expected) . " arguments of [" . $this->_renderArguments($expected) . "] but got " . count($parameters) . " arguments of [" . $this->_renderArguments($parameters) . "]"; } $messages = array(); for ($i = 0; $i < count($expected); $i++) { $comparison = $this->_coerceToExpectation($expected[$i]); if (! $comparison->test($parameters[$i])) { $messages[] = "parameter " . ($i + 1) . " with [" . $comparison->overlayMessage($parameters[$i]) . "]"; } } return "Parameter expectation differs at " . implode(" and ", $messages); } function _coerceToExpectation($expected) { if (SimpleExpectation::isExpectation($expected)) { return $expected; } return new IdenticalExpectation($expected); } function _renderArguments($args) { $descriptions = array(); if (is_array($args)) { foreach ($args as $arg) { $dumper = &new SimpleDumper(); $descriptions[] = $dumper->describeValue($arg); } } return implode(', ', $descriptions); } } class CallCountExpectation extends SimpleExpectation { var $_method; var $_count; function CallCountExpectation($method, $count, $message = '%s') { $this->_method = $method; $this->_count = $count; $this->SimpleExpectation($message); } function test($compare) { return ($this->_count == $compare); } function testMessage($compare) { return 'Expected call count for [' . $this->_method . '] was [' . $this->_count . '] got [' . $compare . ']'; } } class MinimumCallCountExpectation extends SimpleExpectation { var $_method; var $_count; function MinimumCallCountExpectation($method, $count, $message = '%s') { $this->_method = $method; $this->_count = $count; $this->SimpleExpectation($message); } function test($compare) { return ($this->_count <= $compare); } function testMessage($compare) { return 'Minimum call count for [' . $this->_method . '] was [' . $this->_count . '] got [' . $compare . ']'; } } class MaximumCallCountExpectation extends SimpleExpectation { var $_method; var $_count; function MaximumCallCountExpectation($method, $count, $message = '%s') { $this->_method = $method; $this->_count = $count; $this->SimpleExpectation($message); } function test($compare) { return ($this->_count >= $compare); } function testMessage($compare) { return 'Maximum call count for [' . $this->_method . '] was [' . $this->_count . '] got [' . $compare . ']'; } } class CallMap { var $_map; function CallMap() { $this->_map = array(); } function addValue($parameters, $value) { $this->addReference($parameters, $value); } function addReference($parameters, &$reference) { $place = count($this->_map); $this->_map[$place] = array(); $this->_map[$place]["params"] = new ParametersExpectation($parameters); $this->_map[$place]["content"] = &$reference; } function &findFirstMatch($parameters) { $slot = $this->_findFirstSlot($parameters); if (!isset($slot)) { $null = null; return $null; } return $slot["content"]; } function isMatch($parameters) { return ($this->_findFirstSlot($parameters) != null); } function &_findFirstSlot($parameters) { $count = count($this->_map); for ($i = 0; $i < $count; $i++) { if ($this->_map[$i]["params"]->test($parameters)) { return $this->_map[$i]; } } $null = null; return $null; } } class SimpleMock { var $_wildcard = MOCK_ANYTHING; var $_is_strict = true; var $_returns; var $_return_sequence; var $_call_counts; var $_expected_counts; var $_max_counts; var $_expected_args; var $_expected_args_at; function SimpleMock() { $this->_returns = array(); $this->_return_sequence = array(); $this->_call_counts = array(); $test = &$this->_getCurrentTestCase(); $test->tell($this); $this->_expected_counts = array(); $this->_max_counts = array(); $this->_expected_args = array(); $this->_expected_args_at = array(); } function disableExpectationNameChecks() { $this->_is_strict = false; } function setWildcard($wildcard) { $this->_wildcard = $wildcard; } function &_getCurrentTestCase() { return SimpleTest::getCurrent(); } function _checkArgumentsIsArray($args, $task) { if (! is_array($args)) { trigger_error( "Cannot $task as \$args parameter is not an array", E_USER_ERROR); } } function _dieOnNoMethod($method, $task) { if ($this->_is_strict && ! method_exists($this, $method)) { trigger_error( "Cannot $task as no ${method}() in class " . get_class($this), E_USER_ERROR); } } function _replaceWildcards($args) { if ($args === false) { return false; } for ($i = 0; $i < count($args); $i++) { if ($args[$i] === $this->_wildcard) { $args[$i] = new AnythingExpectation(); } } return $args; } function _addCall($method, $args) { if (!isset($this->_call_counts[$method])) { $this->_call_counts[$method] = 0; } $this->_call_counts[$method]++; } function getCallCount($method) { $this->_dieOnNoMethod($method, "get call count"); $method = strtolower($method); if (! isset($this->_call_counts[$method])) { return 0; } return $this->_call_counts[$method]; } function setReturnValue($method, $value, $args = false) { $this->_dieOnNoMethod($method, "set return value"); $args = $this->_replaceWildcards($args); $method = strtolower($method); if (! isset($this->_returns[$method])) { $this->_returns[$method] = new CallMap(); } $this->_returns[$method]->addValue($args, $value); } function setReturnValueAt($timing, $method, $value, $args = false) { $this->_dieOnNoMethod($method, "set return value sequence"); $args = $this->_replaceWildcards($args); $method = strtolower($method); if (! isset($this->_return_sequence[$method])) { $this->_return_sequence[$method] = array(); } if (! isset($this->_return_sequence[$method][$timing])) { $this->_return_sequence[$method][$timing] = new CallMap(); } $this->_return_sequence[$method][$timing]->addValue($args, $value); } function setReturnReference($method, &$reference, $args = false) { $this->_dieOnNoMethod($method, "set return reference"); $args = $this->_replaceWildcards($args); $method = strtolower($method); if (! isset($this->_returns[$method])) { $this->_returns[$method] = new CallMap(); } $this->_returns[$method]->addReference($args, $reference); } function setReturnReferenceAt($timing, $method, &$reference, $args = false) { $this->_dieOnNoMethod($method, "set return reference sequence"); $args = $this->_replaceWildcards($args); $method = strtolower($method); if (! isset($this->_return_sequence[$method])) { $this->_return_sequence[$method] = array(); } if (! isset($this->_return_sequence[$method][$timing])) { $this->_return_sequence[$method][$timing] = new CallMap(); } $this->_return_sequence[$method][$timing]->addReference($args, $reference); } function expectArguments($method, $args, $message = '%s') { $this->_dieOnNoMethod($method, 'set expected arguments'); $this->_checkArgumentsIsArray($args, 'set expected arguments'); $args = $this->_replaceWildcards($args); $message .= Mock::getExpectationLine(' at line [%d]'); $this->_expected_args[strtolower($method)] = new ParametersExpectation($args, $message); } function expectArgumentsAt($timing, $method, $args, $message = '%s') { $this->_dieOnNoMethod($method, 'set expected arguments at time'); $this->_checkArgumentsIsArray($args, 'set expected arguments at time'); $args = $this->_replaceWildcards($args); if (! isset($this->_expected_args_at[$timing])) { $this->_expected_args_at[$timing] = array(); } $method = strtolower($method); $message .= Mock::getExpectationLine(' at line [%d]'); $this->_expected_args_at[$timing][$method] = new ParametersExpectation($args, $message); } function expectCallCount($method, $count, $message = '%s') { $this->_dieOnNoMethod($method, 'set expected call count'); $message .= Mock::getExpectationLine(' at line [%d]'); $this->_expected_counts[strtolower($method)] = new CallCountExpectation($method, $count, $message); } function expectMaximumCallCount($method, $count, $message = '%s') { $this->_dieOnNoMethod($method, 'set maximum call count'); $message .= Mock::getExpectationLine(' at line [%d]'); $this->_max_counts[strtolower($method)] = new MaximumCallCountExpectation($method, $count, $message); } function expectMinimumCallCount($method, $count, $message = '%s') { $this->_dieOnNoMethod($method, 'set minimum call count'); $message .= Mock::getExpectationLine(' at line [%d]'); $this->_expected_counts[strtolower($method)] = new MinimumCallCountExpectation($method, $count, $message); } function expectNever($method, $message = '%s') { $this->expectMaximumCallCount($method, 0, $message); } function expectOnce($method, $args = false, $message = '%s') { $this->expectCallCount($method, 1, $message); if ($args !== false) { $this->expectArguments($method, $args, $message); } } function expectAtLeastOnce($method, $args = false, $message = '%s') { $this->expectMinimumCallCount($method, 1, $message); if ($args !== false) { $this->expectArguments($method, $args, $message); } } function tally() { } function atTestEnd($method) { foreach ($this->_expected_counts as $method => $expectation) { $this->_assertTrue( $expectation->test($this->getCallCount($method)), $expectation->overlayMessage($this->getCallCount($method))); } foreach ($this->_max_counts as $method => $expectation) { if ($expectation->test($this->getCallCount($method))) { $this->_assertTrue( true, $expectation->overlayMessage($this->getCallCount($method))); } } } function &_invoke($method, $args) { $method = strtolower($method); $step = $this->getCallCount($method); $this->_addCall($method, $args); $this->_checkExpectations($method, $args, $step); $result = &$this->_getReturn($method, $args, $step); return $result; } function &_getReturn($method, $args, $step) { if (isset($this->_return_sequence[$method][$step])) { if ($this->_return_sequence[$method][$step]->isMatch($args)) { $result = &$this->_return_sequence[$method][$step]->findFirstMatch($args); return $result; } } if (isset($this->_returns[$method])) { $result = &$this->_returns[$method]->findFirstMatch($args); return $result; } $null = null; return $null; } function _checkExpectations($method, $args, $timing) { if (isset($this->_max_counts[$method])) { if (! $this->_max_counts[$method]->test($timing + 1)) { $this->_assertTrue( false, $this->_max_counts[$method]->overlayMessage($timing + 1)); } } if (isset($this->_expected_args_at[$timing][$method])) { $this->_assertTrue( $this->_expected_args_at[$timing][$method]->test($args), "Mock method [$method] at [$timing] -> " . $this->_expected_args_at[$timing][$method]->overlayMessage($args)); } elseif (isset($this->_expected_args[$method])) { $this->_assertTrue( $this->_expected_args[$method]->test($args), "Mock method [$method] -> " . $this->_expected_args[$method]->overlayMessage($args)); } } function _assertTrue($assertion, $message) { $test = &$this->_getCurrentTestCase(); $test->assertTrue($assertion, $message); } } class Mock { function Mock() { trigger_error('Mock factory methods are class only.'); } function generate($class, $mock_class = false, $methods = false) { $generator = new MockGenerator($class, $mock_class); return $generator->generate($methods); } function generatePartial($class, $mock_class, $methods) { $generator = new MockGenerator($class, $mock_class); return $generator->generatePartial($methods); } function getExpectationLine($format = '%d', $stack = false) { if ($stack === false) { $stack = SimpleTestCompatibility::getStackTrace(); } return SimpleDumper::getFormattedAssertionLine($stack, $format, 'expect'); } } class Stub extends Mock { } class MockGenerator { var $_class; var $_mock_class; var $_mock_base; var $_reflection; function MockGenerator($class, $mock_class) { $this->_class = $class; $this->_mock_class = $mock_class; $this->_mock_base = SimpleTest::getMockBaseClass(); $this->_reflection = new SimpleReflection($this->_class); } function generate($methods) { if (! $this->_reflection->classOrInterfaceExists()) { return false; } if (! $this->_mock_class) { $this->_mock_class = 'Mock' . $this->_class; } $mock_reflection = new SimpleReflection($this->_mock_class); if ($mock_reflection->classExistsSansAutoload()) { return false; } return eval( $this->_createClassCode($methods ? $methods : array()) . " return true;"); } function generatePartial($methods) { if (! $this->_reflection->classExists($this->_class)) { return false; } $mock_reflection = new SimpleReflection($this->_mock_class); if ($mock_reflection->classExistsSansAutoload()) { trigger_error("Partial mock class [$mock_class] already exists"); return false; } return eval($this->_extendClassCode($methods)); } function _createClassCode($methods) { $implements = ''; $interfaces = $this->_reflection->getInterfaces(); if (count($interfaces) > 0) { $implements = 'implements ' . implode(', ', $interfaces); } $code = "class " . $this->_mock_class . " extends " . $this->_mock_base . " $implements {\n"; $code .= "    function " . $this->_mock_class . "() {\n"; $code .= "        \$this->" . $this->_mock_base . "();\n"; $code .= "    }\n"; $code .= $this->_createHandlerCode($methods); $code .= "}\n"; return $code; } function _extendClassCode($methods) { $code = "class " . $this->_mock_class . " extends " . $this->_class . " {\n"; $code .= "    var \$_mock;\n"; $code .= $this->_addMethodList($methods); $code .= "\n"; $code .= "    function " . $this->_mock_class . "() {\n"; $code .= "        \$this->_mock = &new " . $this->_mock_base . "();\n"; $code .= "        \$this->_mock->disableExpectationNameChecks();\n"; $code .= "    }\n"; $code .= $this->_chainMockReturns(); $code .= $this->_chainMockExpectations(); $code .= $this->_overrideMethods($methods); $code .= "}\n"; return $code; } function _createHandlerCode($methods) { $code = ''; $methods = array_merge($methods, $this->_reflection->getMethods()); foreach ($methods as $method) { if ($this->_isConstructor($method)) { continue; } $mock_reflection = new SimpleReflection($this->_mock_base); if (in_array($method, $mock_reflection->getMethods())) { continue; } $code .= "    " . $this->_reflection->getSignature($method) . " {\n"; $code .= "        \$args = func_get_args();\n"; $code .= "        \$result = &\$this->_invoke(\"$method\", \$args);\n"; $code .= "        return \$result;\n"; $code .= "    }\n"; } return $code; } function _isConstructor($method) { return in_array( strtolower($method), array('__construct', '__destruct', '__clone')); } function _addMethodList($methods) { return "    var \$_mocked_methods = array('" . implode("', '", $methods) . "');\n"; } function _bailOutIfNotMocked($alias) { $code = "        if (! in_array($alias, \$this->_mocked_methods)) {\n"; $code .= "            trigger_error(\"Method [$alias] is not mocked\");\n"; $code .= "            \$null = null;\n"; $code .= "            return \$null;\n"; $code .= "        }\n"; return $code; } function _chainMockReturns() { $code = "    function setReturnValue(\$method, \$value, \$args = false) {\n"; $code .= $this->_bailOutIfNotMocked("\$method"); $code .= "        \$this->_mock->setReturnValue(\$method, \$value, \$args);\n"; $code .= "    }\n"; $code .= "    function setReturnValueAt(\$timing, \$method, \$value, \$args = false) {\n"; $code .= $this->_bailOutIfNotMocked("\$method"); $code .= "        \$this->_mock->setReturnValueAt(\$timing, \$method, \$value, \$args);\n"; $code .= "    }\n"; $code .= "    function setReturnReference(\$method, &\$ref, \$args = false) {\n"; $code .= $this->_bailOutIfNotMocked("\$method"); $code .= "        \$this->_mock->setReturnReference(\$method, \$ref, \$args);\n"; $code .= "    }\n"; $code .= "    function setReturnReferenceAt(\$timing, \$method, &\$ref, \$args = false) {\n"; $code .= $this->_bailOutIfNotMocked("\$method"); $code .= "        \$this->_mock->setReturnReferenceAt(\$timing, \$method, \$ref, \$args);\n"; $code .= "    }\n"; return $code; } function _chainMockExpectations() { $code = "    function expectArguments(\$method, \$args = false) {\n"; $code .= $this->_bailOutIfNotMocked("\$method"); $code .= "        \$this->_mock->expectArguments(\$method, \$args);\n"; $code .= "    }\n"; $code .= "    function expectArgumentsAt(\$timing, \$method, \$args = false) {\n"; $code .= $this->_bailOutIfNotMocked("\$method"); $code .= "        \$this->_mock->expectArgumentsAt(\$timing, \$method, \$args);\n"; $code .= "    }\n"; $code .= "    function expectCallCount(\$method, \$count) {\n"; $code .= $this->_bailOutIfNotMocked("\$method"); $code .= "        \$this->_mock->expectCallCount(\$method, \$count);\n"; $code .= "    }\n"; $code .= "    function expectMaximumCallCount(\$method, \$count) {\n"; $code .= $this->_bailOutIfNotMocked("\$method"); $code .= "        \$this->_mock->expectMaximumCallCount(\$method, \$count);\n"; $code .= "    }\n"; $code .= "    function expectMinimumCallCount(\$method, \$count) {\n"; $code .= $this->_bailOutIfNotMocked("\$method"); $code .= "        \$this->_mock->expectMinimumCallCount(\$method, \$count);\n"; $code .= "    }\n"; $code .= "    function expectNever(\$method) {\n"; $code .= $this->_bailOutIfNotMocked("\$method"); $code .= "        \$this->_mock->expectNever(\$method);\n"; $code .= "    }\n"; $code .= "    function expectOnce(\$method, \$args = false) {\n"; $code .= $this->_bailOutIfNotMocked("\$method"); $code .= "        \$this->_mock->expectOnce(\$method, \$args);\n"; $code .= "    }\n"; $code .= "    function expectAtLeastOnce(\$method, \$args = false) {\n"; $code .= $this->_bailOutIfNotMocked("\$method"); $code .= "        \$this->_mock->expectAtLeastOnce(\$method, \$args);\n"; $code .= "    }\n"; $code .= "    function tally() {\n"; $code .= "        \$this->_mock->tally();\n"; $code .= "    }\n"; return $code; } function _overrideMethods($methods) { $code = ""; foreach ($methods as $method) { $code .= "    " . $this->_reflection->getSignature($method) . " {\n"; $code .= "        \$args = func_get_args();\n"; $code .= "        \$result = &\$this->_mock->_invoke(\"$method\", \$args);\n"; $code .= "        return \$result;\n"; $code .= "    }\n"; } return $code; } } ?>