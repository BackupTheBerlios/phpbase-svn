<?php
 if (! defined('LEXER_ENTER')) { define('LEXER_ENTER', 1); } if (! defined('LEXER_MATCHED')) { define('LEXER_MATCHED', 2); } if (! defined('LEXER_UNMATCHED')) { define('LEXER_UNMATCHED', 3); } if (! defined('LEXER_EXIT')) { define('LEXER_EXIT', 4); } if (! defined('LEXER_SPECIAL')) { define('LEXER_SPECIAL', 5); } class ParallelRegex { var $_patterns; var $_labels; var $_regex; var $_case; function ParallelRegex($case) { $this->_case = $case; $this->_patterns = array(); $this->_labels = array(); $this->_regex = null; } function addPattern($pattern, $label = true) { $count = count($this->_patterns); $this->_patterns[$count] = $pattern; $this->_labels[$count] = $label; $this->_regex = null; } function match($subject, &$match) { if (count($this->_patterns) == 0) { return false; } if (! preg_match($this->_getCompoundedRegex(), $subject, $matches)) { $match = ''; return false; } $match = $matches[0]; for ($i = 1; $i < count($matches); $i++) { if ($matches[$i]) { return $this->_labels[$i - 1]; } } return true; } function _getCompoundedRegex() { if ($this->_regex == null) { for ($i = 0, $count = count($this->_patterns); $i < $count; $i++) { $this->_patterns[$i] = '(' . str_replace( array('/', '(', ')'), array('\/', '\(', '\)'), $this->_patterns[$i]) . ')'; } $this->_regex = "/" . implode("|", $this->_patterns) . "/" . $this->_getPerlMatchingFlags(); } return $this->_regex; } function _getPerlMatchingFlags() { return ($this->_case ? "msS" : "msSi"); } } class SimpleStateStack { var $_stack; function SimpleStateStack($start) { $this->_stack = array($start); } function getCurrent() { return $this->_stack[count($this->_stack) - 1]; } function enter($state) { array_push($this->_stack, $state); } function leave() { if (count($this->_stack) == 1) { return false; } array_pop($this->_stack); return true; } } class SimpleLexer { var $_regexes; var $_parser; var $_mode; var $_mode_handlers; var $_case; function SimpleLexer(&$parser, $start = "accept", $case = false) { $this->_case = $case; $this->_regexes = array(); $this->_parser = &$parser; $this->_mode = &new SimpleStateStack($start); $this->_mode_handlers = array($start => $start); } function addPattern($pattern, $mode = "accept") { if (! isset($this->_regexes[$mode])) { $this->_regexes[$mode] = new ParallelRegex($this->_case); } $this->_regexes[$mode]->addPattern($pattern); if (! isset($this->_mode_handlers[$mode])) { $this->_mode_handlers[$mode] = $mode; } } function addEntryPattern($pattern, $mode, $new_mode) { if (! isset($this->_regexes[$mode])) { $this->_regexes[$mode] = new ParallelRegex($this->_case); } $this->_regexes[$mode]->addPattern($pattern, $new_mode); if (! isset($this->_mode_handlers[$new_mode])) { $this->_mode_handlers[$new_mode] = $new_mode; } } function addExitPattern($pattern, $mode) { if (! isset($this->_regexes[$mode])) { $this->_regexes[$mode] = new ParallelRegex($this->_case); } $this->_regexes[$mode]->addPattern($pattern, "__exit"); if (! isset($this->_mode_handlers[$mode])) { $this->_mode_handlers[$mode] = $mode; } } function addSpecialPattern($pattern, $mode, $special) { if (! isset($this->_regexes[$mode])) { $this->_regexes[$mode] = new ParallelRegex($this->_case); } $this->_regexes[$mode]->addPattern($pattern, "_$special"); if (! isset($this->_mode_handlers[$special])) { $this->_mode_handlers[$special] = $special; } } function mapHandler($mode, $handler) { $this->_mode_handlers[$mode] = $handler; } function parse($raw) { if (! isset($this->_parser)) { return false; } $length = strlen($raw); while (is_array($parsed = $this->_reduce($raw))) { list($raw, $unmatched, $matched, $mode) = $parsed; if (! $this->_dispatchTokens($unmatched, $matched, $mode)) { return false; } if ($raw === '') { return true; } if (strlen($raw) == $length) { return false; } $length = strlen($raw); } if (! $parsed) { return false; } return $this->_invokeParser($raw, LEXER_UNMATCHED); } function _dispatchTokens($unmatched, $matched, $mode = false) { if (! $this->_invokeParser($unmatched, LEXER_UNMATCHED)) { return false; } if (is_bool($mode)) { return $this->_invokeParser($matched, LEXER_MATCHED); } if ($this->_isModeEnd($mode)) { if (! $this->_invokeParser($matched, LEXER_EXIT)) { return false; } return $this->_mode->leave(); } if ($this->_isSpecialMode($mode)) { $this->_mode->enter($this->_decodeSpecial($mode)); if (! $this->_invokeParser($matched, LEXER_SPECIAL)) { return false; } return $this->_mode->leave(); } $this->_mode->enter($mode); return $this->_invokeParser($matched, LEXER_ENTER); } function _isModeEnd($mode) { return ($mode === "__exit"); } function _isSpecialMode($mode) { return (strncmp($mode, "_", 1) == 0); } function _decodeSpecial($mode) { return substr($mode, 1); } function _invokeParser($content, $is_match) { if (($content === '') || ($content === false)) { return true; } $handler = $this->_mode_handlers[$this->_mode->getCurrent()]; return $this->_parser->$handler($content, $is_match); } function _reduce($raw) { if ($action = $this->_regexes[$this->_mode->getCurrent()]->match($raw, $match)) { $unparsed_character_count = strpos($raw, $match); $unparsed = substr($raw, 0, $unparsed_character_count); $raw = substr($raw, $unparsed_character_count + strlen($match)); return array($raw, $unparsed, $match, $action); } return true; } } class SimpleSaxParser { var $_lexer; var $_listener; var $_tag; var $_attributes; var $_current_attribute; function SimpleSaxParser(&$listener) { $this->_listener = &$listener; $this->_lexer = &$this->createLexer($this); $this->_tag = ''; $this->_attributes = array(); $this->_current_attribute = ''; } function parse($raw) { return $this->_lexer->parse($raw); } function &createLexer(&$parser) { $lexer = &new SimpleLexer($parser, 'text'); $lexer->mapHandler('text', 'acceptTextToken'); SimpleSaxParser::_addSkipping($lexer); foreach (SimpleSaxParser::_getParsedTags() as $tag) { SimpleSaxParser::_addTag($lexer, $tag); } SimpleSaxParser::_addInTagTokens($lexer); return $lexer; } function _getParsedTags() { return array('a', 'title', 'form', 'input', 'button', 'textarea', 'select', 'option', 'frameset', 'frame', 'label'); } function _addSkipping(&$lexer) { $lexer->mapHandler('css', 'ignore'); $lexer->addEntryPattern('<style', 'text', 'css'); $lexer->addExitPattern('</style>', 'css'); $lexer->mapHandler('js', 'ignore'); $lexer->addEntryPattern('<script', 'text', 'js'); $lexer->addExitPattern('</script>', 'js'); $lexer->mapHandler('comment', 'ignore'); $lexer->addEntryPattern('<!--', 'text', 'comment'); $lexer->addExitPattern('-->', 'comment'); } function _addTag(&$lexer, $tag) { $lexer->addSpecialPattern("</$tag>", 'text', 'acceptEndToken'); $lexer->addEntryPattern("<$tag", 'text', 'tag'); } function _addInTagTokens(&$lexer) { $lexer->mapHandler('tag', 'acceptStartToken'); $lexer->addSpecialPattern('\s+', 'tag', 'ignore'); SimpleSaxParser::_addAttributeTokens($lexer); $lexer->addExitPattern('>', 'tag'); } function _addAttributeTokens(&$lexer) { $lexer->mapHandler('dq_attribute', 'acceptAttributeToken'); $lexer->addEntryPattern('=\s*"', 'tag', 'dq_attribute'); $lexer->addPattern("\\\\\"", 'dq_attribute'); $lexer->addExitPattern('"', 'dq_attribute'); $lexer->mapHandler('sq_attribute', 'acceptAttributeToken'); $lexer->addEntryPattern("=\s*'", 'tag', 'sq_attribute'); $lexer->addPattern("\\\\'", 'sq_attribute'); $lexer->addExitPattern("'", 'sq_attribute'); $lexer->mapHandler('uq_attribute', 'acceptAttributeToken'); $lexer->addSpecialPattern('=\s*[^>\s]*', 'tag', 'uq_attribute'); } function acceptStartToken($token, $event) { if ($event == LEXER_ENTER) { $this->_tag = strtolower(substr($token, 1)); return true; } if ($event == LEXER_EXIT) { $success = $this->_listener->startElement( $this->_tag, $this->_attributes); $this->_tag = ""; $this->_attributes = array(); return $success; } if ($token != "=") { $this->_current_attribute = strtolower(SimpleSaxParser::decodeHtml($token)); $this->_attributes[$this->_current_attribute] = ""; } return true; } function acceptEndToken($token, $event) { if (! preg_match('/<\/(.*)>/', $token, $matches)) { return false; } return $this->_listener->endElement(strtolower($matches[1])); } function acceptAttributeToken($token, $event) { if ($event == LEXER_UNMATCHED) { $this->_attributes[$this->_current_attribute] .= SimpleSaxParser::decodeHtml($token); } if ($event == LEXER_SPECIAL) { $this->_attributes[$this->_current_attribute] .= preg_replace('/^=\s*/' , '', SimpleSaxParser::decodeHtml($token)); } return true; } function acceptEntityToken($token, $event) { } function acceptTextToken($token, $event) { return $this->_listener->addContent($token); } function ignore($token, $event) { return true; } function decodeHtml($html) { static $translations; if (! isset($translations)) { $translations = array_flip(get_html_translation_table(HTML_ENTITIES)); } return strtr($html, $translations); } function normalise($html) { $text = preg_replace('|<!--.*?-->|', '', $html); $text = preg_replace('|<img.*?alt\s*=\s*"(.*?)".*?>|', ' \1 ', $text); $text = preg_replace('|<img.*?alt\s*=\s*\'(.*?)\'.*?>|', ' \1 ', $text); $text = preg_replace('|<img.*?alt\s*=\s*([a-zA-Z_]+).*?>|', ' \1 ', $text); $text = preg_replace('|<.*?>|', '', $text); $text = SimpleSaxParser::decodeHtml($text); $text = preg_replace('|\s+|', ' ', $text); return trim($text); } } class SimpleSaxListener { function SimpleSaxListener() { } function startElement($name, $attributes) { } function endElement($name) { } function addContent($text) { } } ?>