<?php
 require_once(dirname(__FILE__) . '/dumper.php'); require_once(dirname(__FILE__) . '/compatibility.php'); class SimpleExpectation { var $_dumper; var $_message; function SimpleExpectation($message = '%s') { $this->_dumper = &new SimpleDumper(); $this->_message = $message; } function test($compare) { } function testMessage($compare) { } function overlayMessage($compare) { return sprintf($this->_message, $this->testMessage($compare)); } function &_getDumper() { return $this->_dumper; } function isExpectation($expectation) { return is_object($expectation) && SimpleTestCompatibility::isA($expectation, 'SimpleExpectation'); } } class EqualExpectation extends SimpleExpectation { var $_value; function EqualExpectation($value, $message = '%s') { $this->SimpleExpectation($message); $this->_value = $value; } function test($compare) { return (($this->_value == $compare) && ($compare == $this->_value)); } function testMessage($compare) { if ($this->test($compare)) { return "Equal expectation [" . $this->_dumper->describeValue($this->_value) . "]"; } else { return "Equal expectation fails " . $this->_dumper->describeDifference($this->_value, $compare); } } function _getValue() { return $this->_value; } } class NotEqualExpectation extends EqualExpectation { function NotEqualExpectation($value, $message = '%s') { $this->EqualExpectation($value, $message); } function test($compare) { return ! parent::test($compare); } function testMessage($compare) { $dumper = &$this->_getDumper(); if ($this->test($compare)) { return "Not equal expectation passes " . $dumper->describeDifference($this->_getValue(), $compare); } else { return "Not equal expectation fails [" . $dumper->describeValue($this->_getValue()) . "] matches"; } } } class WithinMarginExpectation extends SimpleExpectation { var $_upper; var $_lower; function WithinMarginExpectation($value, $margin, $message = '%s') { $this->SimpleExpectation($message); $this->_upper = $value + $margin; $this->_lower = $value - $margin; } function test($compare) { return (($compare <= $this->_upper) && ($compare >= $this->_lower)); } function testMessage($compare) { if ($this->test($compare)) { return $this->_withinMessage($compare); } else { return $this->_outsideMessage($compare); } } function _withinMessage($compare) { return "Within expectation [" . $this->_dumper->describeValue($this->_lower) . "] and [" . $this->_dumper->describeValue($this->_upper) . "]"; } function _outsideMessage($compare) { if ($compare > $this->_upper) { return "Outside expectation " . $this->_dumper->describeDifference($compare, $this->_upper); } else { return "Outside expectation " . $this->_dumper->describeDifference($compare, $this->_lower); } } } class OutsideMarginExpectation extends WithinMarginExpectation { function OutsideMarginExpectation($value, $margin, $message = '%s') { $this->WithinMarginExpectation($value, $margin, $message); } function test($compare) { return ! parent::test($compare); } function testMessage($compare) { if (! $this->test($compare)) { return $this->_withinMessage($compare); } else { return $this->_outsideMessage($compare); } } } class IdenticalExpectation extends EqualExpectation { function IdenticalExpectation($value, $message = '%s') { $this->EqualExpectation($value, $message); } function test($compare) { return SimpleTestCompatibility::isIdentical($this->_getValue(), $compare); } function testMessage($compare) { $dumper = &$this->_getDumper(); if ($this->test($compare)) { return "Identical expectation [" . $dumper->describeValue($this->_getValue()) . "]"; } else { return "Identical expectation [" . $dumper->describeValue($this->_getValue()) . "] fails with [" . $dumper->describeValue($compare) . "] " . $dumper->describeDifference($this->_getValue(), $compare, TYPE_MATTERS); } } } class NotIdenticalExpectation extends IdenticalExpectation { function NotIdenticalExpectation($value, $message = '%s') { $this->IdenticalExpectation($value, $message); } function test($compare) { return ! parent::test($compare); } function testMessage($compare) { $dumper = &$this->_getDumper(); if ($this->test($compare)) { return "Not identical expectation passes " . $dumper->describeDifference($this->_getValue(), $compare, TYPE_MATTERS); } else { return "Not identical expectation [" . $dumper->describeValue($this->_getValue()) . "] matches"; } } } class PatternExpectation extends SimpleExpectation { var $_pattern; function PatternExpectation($pattern, $message = '%s') { $this->SimpleExpectation($message); $this->_pattern = $pattern; } function _getPattern() { return $this->_pattern; } function test($compare) { return (boolean)preg_match($this->_getPattern(), $compare); } function testMessage($compare) { if ($this->test($compare)) { return $this->_describePatternMatch($this->_getPattern(), $compare); } else { $dumper = &$this->_getDumper(); return "Pattern [" . $this->_getPattern() . "] not detected in [" . $dumper->describeValue($compare) . "]"; } } function _describePatternMatch($pattern, $subject) { preg_match($pattern, $subject, $matches); $position = strpos($subject, $matches[0]); $dumper = &$this->_getDumper(); return "Pattern [$pattern] detected at character [$position] in [" . $dumper->describeValue($subject) . "] as [" . $matches[0] . "] in region [" . $dumper->clipString($subject, 100, $position) . "]"; } } class WantedPatternExpectation extends PatternExpectation { } class NoPatternExpectation extends PatternExpectation { function NoPatternExpectation($pattern, $message = '%s') { $this->PatternExpectation($pattern, $message); } function test($compare) { return ! parent::test($compare); } function testMessage($compare) { if ($this->test($compare)) { $dumper = &$this->_getDumper(); return "Pattern [" . $this->_getPattern() . "] not detected in [" . $dumper->describeValue($compare) . "]"; } else { return $this->_describePatternMatch($this->_getPattern(), $compare); } } } class UnwantedPatternExpectation extends NoPatternExpectation { } class IsAExpectation extends SimpleExpectation { var $_type; function IsAExpectation($type, $message = '%s') { $this->SimpleExpectation($message); $this->_type = $type; } function _getType() { return $this->_type; } function test($compare) { if (is_object($compare)) { return SimpleTestCompatibility::isA($compare, $this->_type); } else { return (strtolower(gettype($compare)) == $this->_canonicalType($this->_type)); } } function _canonicalType($type) { $type = strtolower($type); $map = array( 'bool' => 'boolean', 'float' => 'double', 'real' => 'double', 'int' => 'integer'); if (isset($map[$type])) { $type = $map[$type]; } return $type; } function testMessage($compare) { $dumper = &$this->_getDumper(); return "Value [" . $dumper->describeValue($compare) . "] should be type [" . $this->_type . "]"; } } class NotAExpectation extends IsAExpectation { var $_type; function NotAExpectation($type, $message = '%s') { $this->IsAExpectation($type, $message); } function test($compare) { return ! parent::test($compare); } function testMessage($compare) { $dumper = &$this->_getDumper(); return "Value [" . $dumper->describeValue($compare) . "] should not be type [" . $this->_getType() . "]"; } } class MethodExistsExpectation extends SimpleExpectation { var $_method; function MethodExistsExpectation($method, $message = '%s') { $this->SimpleExpectation($message); $this->_method = &$method; } function test($compare) { return (boolean)(is_object($compare) && method_exists($compare, $this->_method)); } function testMessage($compare) { $dumper = &$this->_getDumper(); if (! is_object($compare)) { return 'No method on non-object [' . $dumper->describeValue($compare) . ']'; } $method = $this->_method; return "Object [" . $dumper->describeValue($compare) . "] should contain method [$method]"; } } ?>
